<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: OAuth2 | The Land of Shattered Dreams]]></title>
  <link href="http://typingincolor.github.io/tags/oauth2/atom.xml" rel="self"/>
  <link href="http://typingincolor.github.io/"/>
  <updated>2014-03-17T13:32:38+00:00</updated>
  <id>http://typingincolor.github.io/</id>
  <author>
    <name><![CDATA[Andrew Braithwaite]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Adventures in OAuth2]]></title>
    <link href="http://typingincolor.github.io/blog/2014/03/17/adventures-in-oauth2/"/>
    <updated>2014-03-17T09:01:00+00:00</updated>
    <id>http://typingincolor.github.io/blog/2014/03/17/adventures-in-oauth2</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/logos/oauth-2-sm.png">
I’ve not been able to blog for a while as a lot of things have been going on.
In November I left <a href="http://www.morrisons.co.uk">Morrisons</a> to take a Solutions Architect role at <a href="http://www.laterooms.com">Laterooms</a>
and it has taken me a while to get settled in and to work out what’s going on.</p>

<p>One of the things I am looking at for Laterooms is how we use APIs to power our
platform. We’ve developed <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">RESTful APIs</a> that are used by our mobile applications
but we can do a whole lot more with our APIs. Long term, I’d like to build our entire
platform on APIs using them as the base for our mobile apps, the websites and our
integration with affiliates and hotel providers. We’ve got a long way to go, but
I guess a journey of a thousand miles begins with a single step.</p>

<p>One of the key considerations we have when designing our API platform is controlling
who has access to our data. We want to build a platform capable of allowing <em>authorized</em>
consumers unlimited access to Lateroom’s data. Note <em>authorized</em> consumers, some data
is public and we want to make it as easy as possible to access it; some data is
most definitely not public and access to it has to be limited.</p>

<p>To help us control access to our APIs I have been looking at various API management
platform and how they implement OAuth2 to provide authorized access to an API. The
three I talk about in this post are from <a href="http://www.apigee.com">Apigee</a>, <a href="http://www.mashery.com">Mashery</a> and <a href="http://www.mulesoft.com">Mulesoft</a>.</p>

<h3 id="oauth2">OAuth2</h3>
<p>Before we start I supose it is worth talking a bit about <a href="http://oauth.net/2/">OAuth2</a>. To quote <a href="http://en.wikipedia.org/wiki/OAuth">wikipedia</a>:</p>

<blockquote>
  <p>OAuth is an open standard for authorization. OAuth provides a method for clients
to access server resources on behalf of a resource owner such as a different
client or an end-user. It also provides a process for end-users to authorize
third-party access to their server resources without sharing their credentials,
typically a username and password pair, using user-agent redirections.</p>
</blockquote>

<p>The OAuth2 <a href="http://tools.ietf.org/html/rfc6749">spec</a> is a long and complicated document with many, many options.
To compare the three management platforms I built a simple API hosted on <a href="https://heroku.com/">Heroku</a>.
I also wrote a simple client web app that consumed the API again hosted on Heroku.
Finally I wired in each of the API management platforms to protect the API and
to ensure only authenticated users could use the client.</p>

<p>I used the “Authorization Code” flow to authenticate and authorise the client users,
which means that the client does not need any knowledge of the user’s credentials
and all the authentication and authorization is done on the API side.</p>

<p>At a high level, every API request by the client requires an access token to call a
protected resource. The steps to get an access token are:</p>

<ul>
  <li>the user authenticates themselves using a web application hosted on the API side</li>
  <li>the client application is passed an authorization code via a callback method.
The client exchanges this code for an access token, authenticating itself with a
client ID and secret.</li>
  <li>the client attaches the access token to any API calls</li>
</ul>

<p>Each of the API management platform achieves this in a slightly different way.</p>

<h3 id="mashery">Mashery</h3>
<p>To implement the flow in Mashery I wrote a simple node app that presented a user
a screen to enter their username and password and which validated them. The user
clicks on a link in the client app and is taken to this validation screen.</p>

<p>If the validation succeeds the web app uses a Mashery API to generate an authorization
code and this is passed back to the client via it’s callback url. The client makes a call
to a “token” endpoint configured in the Mashery API and which responds with an access token.
This token is passed with every subsequent API call and the Mashery platform ensures that
it is valid.</p>

<p>This is the implementation I tried last, and it took me very little effort to
change the code a developed using Apigee to work with Mashery.</p>

<h3 id="apigee">Apigee</h3>
<p>Apigee’s approach is slightly different to Mashery. I had to expose three
endpoints in Apigee. The first endpoint redirects to the login application where
the user enters their details. If the details are correct, the login app calls
the second endpoint which generates an authorization code and passes it to the
client app via its callback url. The client then uses the third endpoint to
exchange the code for an access token.</p>

<p>It took me a while to remember how OAuth works, but once I had that the example
from Apigee was easy to follow and I got things up and running pretty quickly.</p>

<h3 id="mulesoft">Mulesoft</h3>
<p>Mulesoft is a relatively new player in the API management space, primarily being
known for their ESB.The biggest difference between the the solution I built with
this and the others was that Mulesoft provided the login application, with no
ability to develop your own. It is relatively simple to plug this login app
into an existing database, and you do have control over how it looks but it does
mean you have to know about <a href="http://projects.spring.io/spring-framework/">Spring</a> and Java (both of which I do). Getting
an access token was easy, and wiring in the API was pretty simple. I did like
that you can run everything on a local machine whilst developing - but it also
required the most technical knowledge to get working.</p>

<h3 id="conclusion">Conclusion</h3>
<p>All three platforms made it simple to implement the required functionality.
Mashery and Apigee’s approach are pretty similar (although the platforms are
quite different), and Mulesoft’s approach also work’s well.</p>

]]></content>
  </entry>
  
</feed>
